Algoritmo Dijkstra_Heap(G(V,E), s, t)
    var dist[0..n-1], previo[0..n-1], visitado[0..n-1]      // O(n) memoria
    var Q : minheap de pares (clave, nodo)                   // O(n) memoria

    // --- Inicialización: O(n) ---
    para i := 0 hasta n-1 hacer
        dist[i] := ∞
        previo[i] := -1
        visitado[i] := falso
    fin para
    dist[s] := 0                                             // O(1)
    insertar(Q, (0, s))                                      // O(log n)

    // --- Bucle principal: O((n + m) log n) ---
    do Q ≠ vacío →
        (d, u) := extraerMin(Q)                              // O(log n)
        si visitado[u] → skip fi                             // O(1)
        visitado[u] := verdadero                             // O(1)

        si u = t → salir od fi                               // O(1) (optimización: parada temprana)

        // --- Relajaciones ---
        para cada (v, peso) en G[u] →                        // total O(m)
            si ¬visitado[v] ∧ d + peso < dist[v] →           // O(1)
                dist[v] := d + peso                          // O(1)
                previo[v] := u                               // O(1)
                insertar(Q, (dist[v], v))                    // O(log n) por relajación efectiva
            fi
        rof
    od

    retornar reconstruirCamino(previo, t), dist[t]           // O(n) para la ruta
Fin Algoritmo
