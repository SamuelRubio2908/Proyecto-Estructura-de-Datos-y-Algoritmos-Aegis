import heapq  # Importa la librería para usar colas de prioridad (min-heap).
# Complejidad: O(1) en tiempo y espacio (solo carga el módulo).

def dijkstra(grafo, origen):
    # Inicializa las distancias a infinito para cada nodo del grafo
    dist = {nodo: float('inf') for nodo in grafo}  
    # Tiempo: O(V) donde V = número de vértices
    # Espacio: O(V) para almacenar las distancias

    dist[origen] = 0  
    # Tiempo: O(1)
    # Espacio: ya está dentro del diccionario

    pq = [(0, origen)]  # Cola de prioridad con tupla (distancia, nodo)
    # Tiempo: O(1)
    # Espacio: O(1) inicial, pero puede crecer hasta O(V)

    while pq:  # Se ejecuta mientras haya elementos en la cola
        # heapq.heappop extrae el menor elemento
        distancia, nodo = heapq.heappop(pq)
        # Tiempo: O(log V) por operación de heap
        # Espacio: no adicional, solo variables locales

        if distancia > dist[nodo]:
            continue  
            # Tiempo: O(1)

        # Recorremos vecinos del nodo
        for vecino, peso in grafo[nodo]:  
            # Tiempo: se ejecuta tantas veces como aristas E
            # Espacio: O(1) variables locales

            nueva_dist = distancia + peso  
            # Tiempo: O(1)

            if nueva_dist < dist[vecino]:  
                # Tiempo: O(1) comparación

                dist[vecino] = nueva_dist  
                # Tiempo: O(1)
                # Espacio: ya reservado en diccionario

                heapq.heappush(pq, (nueva_dist, vecino))  
                # Tiempo: O(log V) por inserción en heap
                # Espacio: la cola puede almacenar hasta O(E) pares en el peor caso

    return dist  
    # Devuelve las distancias mínimas
    # Espacio final: O(V)
